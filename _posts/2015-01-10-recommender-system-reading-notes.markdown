---
layout: post
title: "推荐引擎相关文章阅读笔记"
categories: Notes
---
Source
----------------
[探索推荐引擎内部的秘密][1] 

第 1 部分: 推荐引擎初探
------------------------------
###信息发现 
推荐引擎针对用户不明确自己的需要却需要符合自己口味和喜好的结果。在用户明确自己需求的时候，搜索引擎可以快速的帮用户查找需要的信息。

+ 推荐引擎
    数据源：要推荐物品或内容的元数据，系统用户的基本信息，用户对物品或者信息的偏好
    + 偏好信息可分两类：显式的用户反馈，隐式的用户反馈

+ 推荐引擎的分类
    根据分类标准有不同的分类：

    1. 根据是否为不同的用户推荐不同的数据：推荐引擎可以分为基于大众行为的推荐引擎和个性化推荐引擎

    2. 根据推荐引擎的数据源，即如何发现数据的相关性：
        + 根据系统用户的基本信息发现用户的相关程度，这种被称为基于人口统计学的推荐（Demographic-based Recommendation）
        + 根据推荐物品或内容的元数据，发现物品或者内容的相关性，这种被称为基于内容的推荐（Content-based Recommendation）
        + 根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性，这种被称为基于协同过滤的推荐（Collaborative Filtering-based Recommendation）

    3. 根据推荐模型的建立方式：
        + 基于物品和用户本身的，预测每个用户对于每个物品的喜好程度
        + 基于关联规则的推荐（Rule-based Recommendation）：挖掘数据依赖关系，诸如“购物篮问题”
        + 基于模型的推荐（Model-based Recommendation）：用机器学习的方法用用户喜好信息训练出一个模型，然后基于该模型推荐

###深入推荐机制
1. 基于人口统计学的推荐：根据用户基本信息发现用户相关程度，然后将相似用户喜爱的物品/内容推荐。
    + 优点：
        1. 不使用当前用户对物品或内容的喜好历史，新用户没有cold start问题；
        2. 不依赖物品本身数据，domain-independent
    + 缺点：分类粗糙，有时推荐结果不精准；用户信息不好收集。
2. 基于内容的推荐：先根据要推荐的物品或内容元数据发掘相关性，然后根据用户喜好记录推荐相似的事物。
    + 优点：建模用户的兴趣，提供更精准的推荐
    + 缺点：
        1. 推荐的质量依赖于对物品建模的完整度
        2. 事物相似度的分析仅依赖事物本身的特征，没考虑人对事物的态度
        3. 需要基于用户的喜好历史推荐，对新用户有cold start问题
        这个模型应用广泛而且有不少成功案例， 诸如pandora
3. 基于协同过滤的推荐： 
可以分为三个子类：基于用户的推荐（User-based Recommendation），基于事物的推荐（Item-based Recommendation）和基于模型的推荐（Model-based Recommendation）

    1. 基于用户的系统过滤推荐   ：根据所有用户对物品或者信息的偏好，发现与当前用户口味和偏好相似的“邻居”用户群，在一般的应用中是采用计算“K- 邻居”的算法；然后，基于这 K 个邻居的历史偏好信息，为当前用户进行推荐。
    >“基于用户的协同过滤推荐机制和基于人口统计学的推荐机制都是计算用户的相似度，并基于“邻居”用户群计算推荐，但它们所不同的是如何计算用户的相似度，基于人口统计学的机制只考虑用户本身的特征，而基于用户的协同过滤机制可是在用户的历史偏好的数据上计算用户的相似度，它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。”
    
    2. 基于事物的协同过滤推荐：基于项目的协同过滤推荐的基本原理也是类似的，只是说它使用所有用户对物品或者信息的偏好，发现物品和物品之间的相似度，然后根据用户的历史偏好信息，将类似的物品推荐给用户。“基于项目的协同过滤推荐和基于内容的推荐其实都是基于物品相似度预测推荐，只是相似度计算的方法不一样，前者是从用户历史的偏好推断，而后者是基于物品本身的属性特征信息”

    3. 基于模型的协同过滤推荐：基于模型的协同过滤推荐就是基于样本的用户喜好信息，训练一个推荐模型，然后根据实时的用户喜好的信息进行预测，计算推荐。
        + 优点：
            1. 无需对物品或用户严格建模，domain-independent; 
            2. 计算出的推荐是开放的，支持发现用户的潜在兴趣 

        + 缺点：
            1. 基于历史数据，有cold start问题；
            2. 效果对历史数据的数量和准确度有依赖；3. 用户历史偏好的存储是用稀疏矩阵存储，有时错误的偏好会对推荐结果准确度有较大影响；4. 对有特殊品味用户推荐效果不佳；5. 对变化的适应度不够
    
4. 混合的推荐机制：加权的混合（Weighted Hybridization），切换的混合（Switching Hybridization），分区的混合（Mixed Hybridization），分层的混合（Meta-Level Hybridization）


[1]: http://www.ibm.com/developerworks/cn/views/web/libraryview.jsp?view_by=search&sort_by=Date&sort_order=desc&view_by=Search&search_by=%E6%8E%A2%E7%B4%A2%E6%8E%A8%E8%8D%90%E5%BC%95%E6%93%8E%E5%86%85%E9%83%A8%E7%9A%84%E7%A7%98%E5%AF%86&dwsearch.x=12&dwsearch.y=11&dwsearch=Go  "探索推荐引擎内部的秘密"
